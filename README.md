# Java-to-Python interop

Класс `eliseev.pythoninterop.executor.message.Message` описывает сообщение, передаваемое между процессами.
Сначала передается текст с типом сообщения, потом разделитель, потом число, являющееся длиной текста сообщения,
потом снова разделитель, и после него сообщение, состоящее из обозначенного числа символов.
Разделителем выбран символ `\n`. В целом можно выбрать любой, от него требуется только чтобы он не мог встречаться в
типе сообщения и в длине(т.е. не состоял из цифр). Символ `\n` не является цифрой, и вряд-ли будет встречаться в имени
типа сообщения, поэтому подходит.

Неприятным моментом оказалось то, что длина строки utf-8 считается по-разному в Java и Python,
поэтому если просто отправлять длину строки, как её считает язык, то в некоторых случаях Python будет останавливаться,
т.к. будет ждать строку длины больше, чем то что ему передали, а Java будет читать текст сообщения не до конца.
Для решения этой проблемы, при передаче сообщений из Java в Python, я пишу длину текста, как её считает Python
(количество Unicode code point'ов, для этого у Java-строк есть специальный метод `codePointCount`),
а при передаче из Python в Java, длина пишется как её считает Java
(количество Unicode code unit'ов, для этого я кодирую строку в utf-16,
получая количество байт ровно в 2 раза большее, чем количество code unit'ов в строке)

Сообщения воспринимаются как текст, при записи куда-либо кодируются в utf-8.

Такой формат достаточно легко разбирать, и он относительно оптимизирован. Конечно, можно было бы напрямую кодировать все
битами (например, т.к. поддерживаемых типов сообщений всего 6, их можно было бы кодировать всего 3мя битами,
вместо 16-120, использующихся сейчас(по 8 на каждый символ в названии), длину также можно передавать как двоичное число,
а не кодировать символы, тем самым экономя количество передаваемой информации), но это значительно усложнило бы код, и
не имело бы слишком много смысла, потому что это не даст значительного прироста к скорости/занимаемой памяти. Такими
оптимизациями можно заняться, если будет необходимо любыми способами увеличить эффективность, и более разумных
оптимизаций уже не останется.

Типы сообщений описаны в классе `eliseev.pythoninterop.executor.message.MessageType`. На данный момент их 6: 4 для
передачи из Java в Python и 2 для передачи ответа обратно в Java.
Из первых 4х два(`TEXT` и `EXPRESSION`) - описанные в условии,
и ещё 2 дополнительных: `SET_OUTPUT_FILE` - для установки файла,
в который печатается текст передаваемый сообщениями `TEXT` и
`EXECUTE` - для вычисления произвольных statement,
в отличие от `EXPRESSION` не возвращает
результат(т.к. его может не быть), сделан для того,
чтобы можно было, например, исполнить `import math`,
после чего на сообщение типа `EXPRESSION`
с текстом `math.cos(math.pi)` мы получим разумный
ответ (-1), а не сообщение об ошибке.
Типы для ответа - `OK` и `ERROR` - их названия вполне объясняют их предназначение.

Из всех способов взаимодействия процессов которые я знаю/смог найти в интернете я решил реализовать 2, имеющие разные
преимущества и недостатки.
Выделен интерфейс для произвольного способа взаимодействия: `eliseev.pythoninterop.executor.PythonExecutor`.
В нем всего 1 метод (не считая переопределенного метода из `AutoClosable`, для того чтобы
использовать `try-with-resources`,
т.к. оба реализованных способа тем или иным образом используют ресурсы, которые необходимо освободить),
который позволяет отправить сообщение и возвращает сообщение-ответ.
Также выделен абстрактный класс `eliseev.pythoninterop.executor.AbstractPythonExecutor`,
т.к. обе реализации имеют некоторый общий код, который было решено вынести.

## Создание дочернего процесса

Первый из способов - создание из процесса Java дочернего Python-процесса и передача сообщений через его потоки
ввода-вывода.

Преимущества метода - передача сообщений происходит +- настолько быстро, насколько возможно межпроцессное
взаимодействие;
метод очень прост в реализации, т.к. в Java достаточно запустить дочерний процесс и писать/читать используя
стандартные `BufferedReader` и `BufferedWriter`, а в Python нужно просто читать/писать в стандартные потоки
ввода-вывода.

Недостатки метода - каждый Java-процесс должен создавать собственный Python процесс для взаимодействия,
невозможно использовать стандартный поток вывода Python для печати чего-либо в консоль,
т.к. он занят для отправки сообщений.

## Подключение по TCP

Второй способ - создаётся Python-процесс, прослушивающий какой-либо порт,
а Java-процесс подключается к этому порту по TCP и передача сообщений происходит через это соединение.

Преимущества метода - множество Java-процессов может одновременно подключиться к одному Python-процессу,
даже можно подключаться к Python-процессу, запущенному на удаленном сервере,
без необходимости иметь интерпретатор python на компьютере, запускающем Java-процесс.

Недостатки метода - необходимо отдельно предварительно запускать Python-процесс;
скорость передачи данных несколько ниже, чем в первом способе, а особенно будет низкая,
в случае если Python-процесс запущен на удаленном сервере;
реализация несколько сложнее: чтение из сокета сложнее, чем из стандартного потока ввода из-за
отсутствия методов вроде `readline`, или `read`, читающего необходимое число символов;

## Демонстрация

Для демонстрации работоспособности написан метод `main` в классе `eliseev.pythoninterop.Main`.
Первый аргумент - `process` или `network`, для выбора способа взаимодействия.
При выборе `network` дополнительно можно передать вторым аргументом `--run`, чтобы запустить Python-сервер,
а также дополнительно можно передать номер порта, который будет прослушивать запущенный сервер(и к которому
, соответственно, будет подключаться Java-процесс). Если не задать порт, будет использовано значение `2323`.

Таким образом можно запустить несколько Java процессов, которые подключатся к одному Python процессу
(при запуске первого передать `network --run`, а всем остальным просто `network`).

Вывод Python-процесса(текста, переданного сообщениями типа `TEXT`) по умолчанию происходит в файл `output.txt`,
это можно поменять передав имя файла с помощью сообщения типа `SET_OUTPUT_FILE`.

Для запуска под Windows возможно придется в коде поменять значение константы `PYTHON_INTERPRETER_NAME`
на `"python"`.

## JAR файл

JAR, имеющий своей точкой входа описанный выше класс `eliseev.pythoninterop.Main`, лежит [тут](./artifacts).
Там же лежит bash-скрипт, написанный для создания этого JAR-файла.

## Тесты

Для тестов используется фреймворк JUnit4, код тестов лежит в [этой папке](./src/test/java/eliseev/pythoninterop).
В класс `eliseev.pythoninterop.BaseExecutorTest` вынесена общая логика тестов для обоих
вариантов реализации взаимодействия(тесты общие,
отличается только способ получения экземпляра `eliseev.pythoninterop.executor.PythonExecutor` и инициализация).
Из-за того, что тесты одинаковые можно сделать некоторые сравнения в скорости работы:
на маленьких тестах network работает быстрее, вероятно потому что ему не надо тратить время на создание Python-процесса.
Но на больших тестах, он работает медленнее, причем наиболее это заметно на тестах с некорректными `EXECUTION`
сообщениями(время отличается примерно в 2 раза),
на остальных тестах время отличается не так сильно, в районе 10%. В чем такая особенность именно этих тестов я объяснить
не могу, но можно сделать вывод,
что разница во времени хоть и заметная, но не слишком критичная в большинстве случаев, поэтому
если есть необходимость в одновременном использовании нескольких Java-процессов,
то network вариант имеет место, иначе, понятно что process вариант будет лучше,
т.к. не требует дополнительного запуска сервера и обрабатывает сообщения быстрее.

## Интеграция Python-файлов в Java-код

В статических полях класса `eliseev.pythoninterop.executor.PythonScriptCreator` записан текст Python-скриптов.
У этого же класса есть методы, которые создают скрипты с этим текстом по заданному пути, если их там ещё нет. Таким
образом, если Python-скриптов по заданному пути ещё нет, мы их там создаём, и дальше можем запускать их в
классах `eliseev.pythoninterop.executor.PythonServer` и `eliseev.pythoninterop.executor.ProcessPythonExecutor`.